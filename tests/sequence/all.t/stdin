cutEmptyParTensor = proc() new (c : {}, d : []) (c{} | d[])
cut_par_cut = proc()
  ( new (c  : !Int, d  : ?Int) ( send c  1 | recv d  (x  : Int) )
  | new (c' : !Int, d' : ?Int) ( send c' 1 | recv d' (x' : Int) )
  )

cut_recv_send_send_recv = proc() new (d : ?Int.!Int, c : !Int.?Int)
  ( send c 1
    recv c (x : Int)
  | recv d (y : Int)
    send d 2
  )

cutSendRecv = proc() new (c : !Int, d : ?Int) ( send c 1 | recv d (x : Int) )
cut_send_recv_recv_send = proc() new (c : !Int.?Int, d : ?Int.!Int)
  ( send c 1
    recv c (x : Int)
  | recv d (y : Int)
    send d 2
  )

cut_send_recv_recv_send_v2 = proc() new (c : !Int.?Int, d : ?Int.!Int)
  ( recv d (y : Int)
    send d 2
  | send c 1
    recv c (x : Int)
  )

double = proc(i : ?Int, r : !Int)
  recv i(xi : Int)
  new (c : ?Int. ?Int. !Int, d)
  (
    recv c(x : Int) recv c(y : Int) send c (x + y)
  |
    send d xi send d xi recv d(z : Int) send r z
  )
fwd2_par2_ten2 = proc(c : Fwd 2 {?Int,!Int.?Int}) fwd 2 {?Int,!Int.?Int} c
fwd3_par2_ten2_ten2 = proc(c : Fwd 3 {?Int,!Int.?Int})
  fwd 3 {?Int,!Int.?Int} c
fwd_par0_ten0 = proc(i : {}, o : []) fwd{}(i,o)
fwd_par2_ten2_expanded =
  proc(i : {?Int, !Int. ?Int}, o : [!Int, ?Int.!Int])
    o[o0,o1]
    i{i0,i1}
    ( recv i0 (xi0 : Int) send o0 xi0
    | recv o1 (xo1 : Int) send i1 xo1
      recv i1 (yi1 : Int) send o1 yi1
    )
fwd_par2_ten2 = proc(i : {?Int,!Int.?Int}, o : [!Int,?Int.!Int]) fwd{?Int,!Int.?Int}(i,o)
fwd_par2_ten2_ten2 =
  proc( i : {?Int,!Int.?Int}
      , o : [!Int,?Int.!Int]
      , l : {!Int,!Int.!Int}
      )
  fwd {?Int,!Int.?Int}(i,o,l)
fwd_par2_ten2_ten2_ten2 =
  proc( i : {?Int,!Int.?Int}
      , o : [!Int,?Int.!Int]
      , l : {!Int,!Int.!Int}
      , m : {!Int,!Int.!Int}
      )
  fwd{?Int,!Int.?Int}(i,o,l,m)
fwd_send_recv = proc(i : ?Int, o : !Int) fwd(?Int)(i,o)
fwd_send_recv_recv_send = proc(i : ?Int. !Int, o : !Int. ?Int) fwd(?Int.!Int)(i,o)
fwd_ten2_par2 = proc(i : [?Int,!Int.?Int], o : {!Int,?Int.!Int}) fwd[?Int,!Int.?Int](i,o)
id : (A : Type)(x : A) -> A

idproc = proc(c : ?Int, d : !Int)
  recv c (y : Int)
  send d (id Int y)
merger_seq_inferred =
 \(m : Int)(n : Int)->
 proc(c0,c1,ci,co)
  recv ci (vi : Vec Int (m + n))
  send c0 (take Int m n vi) -- Since these two sends are on different channels
  send c1 (drop Int m n vi) -- they can commute, thus are actually in parallel
  recv c0 (v0 : Vec Int m)  -- Same here these two recv can commute
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)
merger_seq =
 \(m : Int)(n : Int)->
 proc( c0 : ! Vec Int m. ? Vec Int m
     , c1 : ! Vec Int n. ? Vec Int n
     , ci : ? Vec Int (m + n)
     , co : ! Vec Int (m + n)
     )
  recv ci (vi : Vec Int (m + n))
  send c0 (take Int m n vi) -- Since these two sends are on different channels
  send c1 (drop Int m n vi) -- they can commute, thus are actually in parallel
  recv c0 (v0 : Vec Int m)  -- Same here these two recv can commute
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)
merger_seq_Sort =
 \(m : Int)(n : Int)->
 proc(c : [Sort Int m, Sort Int n] -o Sort Int (m + n))
  c{d,io} d{d0,d1}
  recv io (vi : Vec Int (m + n))
  send d0 (take Int m n vi) -- Since these two sends are on different channels
  send d1 (drop Int m n vi) -- they can commute, thus are actually in parallel
  recv d0 (v0 : Vec Int m)  -- Same here these two recv can commute
  recv d1 (v1 : Vec Int n)
  send io (merge m n v0 v1)
par0 = proc(c : {}) c{}
par1 = proc(c : {!Int}) c{d} send d 42
par2 = proc(c : {!Int,?Int}) c{d,e} recv e (x : Int) send d x
par2mix = proc(c : {!Int,?Int}) c{d,e}(recv e (x : Int) | send d 42)
parallel_assoc_2tensor2_left = proc(cde : [[!Int, !Int], !Int])
  cde[cd,e]
  cd[c,d]
  ( send c 1
  | send d 2
  | send e 3
  )
parallel_assoc_2tensor2_right = proc(cde : [[!Int, !Int], !Int])
  cde[cd,e]
  ( cd[c,d] ( send c 1 | send d 2 )
  | send e 3
  )
parallel_assoc_flat = proc(c : !Int, d : !Int, e : !Int)
  ( send c 1
  | send d 2
  | send e 3
  )
parallel_assoc_left = proc(c : !Int, d : !Int, e : !Int)
  ( ( send c 1 | send d 2 )
  | send e 3
  )
parallel_assoc_right = proc(c : !Int, d : !Int, e : !Int)
  ( send c 1
  | ( send d 2 | send e 3 )
  )
parallel_assoc_tensor3_flat = proc(cde : [!Int, !Int, !Int])
  cde[c,d,e]
  ( send c 1
  | send d 2
  | send e 3
  )
parallel_assoc_tensor3_left = proc(cde : [!Int, !Int, !Int])
  cde[c,d,e]
  ( send c 1
  | ( send d 2 | send e 3 )
  )
parallel_assoc_tensor3_right = proc(cde : [!Int, !Int, !Int])
  cde[c,d,e]
  ( ( send c 1 | send d 2 )
  | send e 3
  )
parallel_tensor4_flat = proc(cd : [!Int,!Int], ef : [!Int,!Int])
  cd[c,d]
  ef[e,f]
  ( send c 1
  | send e 2
  | send d 3
  | send f 4
  )
-- Needs mix
-- [c,d],[e,f] <mix> [c,d,e,f] <split> [c,e],[d,f] <split/split> [c],[e] and [d],[f]
parallel_tensor4_v0 = proc(cd : [!Int,!Int], ef : [!Int,!Int])
  cd[c,d]
  ef[e,f]
  ( ( send c 1 | send e 2 )
  | ( send d 3 | send f 4 )
  )
par_ten1_ten1 = proc(c : {[?Int], [!Int]})
  c{e,d} d[l] e[h]
  recv h (x : Int) send l x
-- Accepted by the checker, makes the compiler loop
par_ten_ten_v0 = proc(c : {[?Int, !Int], [!Int, ?Int]})
  c{e,d} d[k,l] e[h,g]
  ( ( recv h (x : Int)
    | ( send k 1 | recv l (y : Int) )
    )
  | send g 2
  )
par_ten_ten_v1 = proc(c : {[?Int, !Int], [!Int, ?Int]})
  c{e,d} d[k,l] e[h,g]
  ( recv h (x : Int)
  | send k 1
  | recv l (y : Int)
  | send g 2
  )
par_ten_ten_v2 = proc(c : {[?Int, !Int], [!Int, ?Int]})
  c{e,d} d[k,l] e[h,g]
  ( ( send k 1
    | ( recv h (x : Int) | recv l (y : Int) )
    )
  | send g 2
  )
replicate_par = proc(c : {!Int ^ 10})
  c{d}
  slice (d) 10 as i
  send d i
replicate_ten = proc(c : [!Int ^ 10])
  c[d]
  slice (d) 10 as i
  send d i
seq3 = proc(c : [: !Int, !Int, !Int :])
  c[: c0, c1, c2 :]
  send c0 0
  send c1 1
  send c2 2

seq3_seq2 = proc(c : [: !Int, !Int, !Int :], d : [: !Int, !Int :])
  c[: c0, c1, c2 :]
  d[: d0, d1 :]
  send c0 0
  send c1 1
  send d0 0
  send c2 2
  send d1 1

singleRecv = proc(c : ?Int) recv c (x : Int)
singleSend = proc(c : !Int) send c 42
sorter =
 \(n : Int)->
 proc(c : {? Vec Int n, ! Vec Int n})
  c{ci,co}
  recv ci (v : Vec Int n)
  send co (sort n v)
sum_int = proc(a : {?Int ^ 10}, r : !Int)
  new (itmp : !Int.?Int, tmp)
  (send itmp 0
   fwd(?Int)(itmp, r)
  |
   a{ai}
   slice (ai) 10 as i
   recv ai  (x : Int)
   recv tmp (y : Int)
   send tmp (x + y)
  )

ten_loli_par = proc(c : [!Int,!Int] -o {!Int,!Int})
  c{i,o}
  i{i0,i1}
  o{o0,o1}
  ( fwd(?Int)(i0,o0)
  | fwd(?Int)(i1,o1)
  )
ten_par_par_split = proc(c : [{},{}]) c[d,e] (d{} | e{})
tensor0 = proc(c : []) c[]
tensor1 = proc(c : [!Int]) c[d] send d 42
tensor2 = proc(c : [!Int,?Int]) c[d,e](recv e (x : Int) | send d 42)
tensor2_tensor0_tensor0_parallel = proc(cd : [[], []])
  cd[c,d] ( c[] | d[] )
{-
          d[] : [d : []]
       c[]d[] : [c : [], d : []]
cd[c,d]c[]d[] : [cd : [[], []]]
-}
tensor2_tensor0_tensor0_sequence = proc(cd : [[], []])
  cd[c,d] c[] d[]
tensor2_using_dual = proc(c : [!Int,~!Int]) c[d,e](recv e (x : Int) | send d 42)
test2 = proc()
  new (c : {?Int. !Int. ?Int, !Int. ?Int. !Int}, d)
  (
    c{c0,c1}
    recv c0 (x0 : Int)
    send c1 (x0 + 1)
    recv c1 (x1 : Int)
    send c0 (x1 + x0 + 2)
    recv c0 (x2 : Int)
    send c1 (x2 + x1 + x0 + 3)
  | d[d0,d1]
    (
      send d0 1
      recv d0 (y0 : Int)
      send d0 (y0 + 4)
    |
      recv d1 (z0 : Int)
      send d1 (z0 + 5)
      recv d1 (z1 : Int)
    )
  )
test3 = proc()
  new (c : ?Int. [!Int, !Int], d)
  (
    recv c (x0 : Int)
    c[c0,c1]
    ( send c0 x0 | send c1 x0 )
  |
    send d 1
    d{d0,d1}
    ( recv d0 (y0 : Int) | recv d1 (z0 : Int) )
  )
test4 = proc(r : !Int)
  new (c : ?Int. ?Int. ?Int, d)
  (
    recv c (x0 : Int)
    recv c (x1 : Int)
    recv c (x2 : Int)
    send r (x0 + x1 + x2)
  |
    send d 1
    send d 2
    send d 3
  )
zap_ten_fwd = proc(cf : {(?Int -o ?Int) ^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10])
  cf{cfi}
  cn{cni}
  co[coi]
  slice (cfi,cni,coi) 10 as i
  cfi{cfii,cfio}
  ( fwd(?Int)(cni,cfii)
  | fwd(?Int)(cfio,coi)
  )

zap_ten_par = proc(cf : {(?Int -o ?Int) ^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10])
  cf{cfi}
  cn{cni}
  co[coi]
  slice (cfi,cni,coi) 10 as i
  cfi{cfii,cfio}
  ( recv cni (x : Int)
    send cfii x
  | recv cfio (y : Int)
    send coi y
  )

zap_ten_seq = proc(cf : {(?Int -o ?Int) ^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10])
  cf{cfi}
  cn{cni}
  co[coi]
  slice (cfi,cni,coi) 10 as i
  cfi{cfii,cfio}
  recv cni (x : Int)
  send cfii x
  recv cfio (y : Int)
  send coi y

zip_add = proc(xs : {?Int ^ 10}, ys : {?Int ^ 10}, zs : [!Int ^ 10])
  xs{x}
  ys{y}
  zs[z]
  slice (x,y,z) 10 as i
  recv x (a : Int)
  recv y (b : Int)
  send z (a + b)
