cutEmptyParTensor = new (c : {}, d : []) (c{} | d[]).
cut_par_cut =
  ( new (c  : !Int, d  : ?Int) ( send c 1  | recv d  (x : Int) )
  | new (c' : !Int, d' : ?Int) ( send c' 1 | recv d' (x : Int) )
  )
.
cutSendRecv = new (c : !Int, d : ?Int) ( send c 1 | recv d (x : Int) ).
double (i : ?Int, r : !Int) =
  recv i(xi : Int)
  new (c : ?Int. ?Int. !Int, d)
  (
    recv c(x : Int) recv c(y : Int) send c (x + y)
  |
    send d xi send d xi recv d(z : Int) send r z
  ).
fwd_par0_ten0 (i : {}, o : []) = fwd {} i o.
fwd_par2_ten2 (i : {?Int,!Int.?Int}, o : [!Int,?Int.!Int]) = fwd {?Int,!Int.?Int} i o.
fwd_par2_ten2_ten2 ( i : {?Int,!Int.?Int}
                   , o : [!Int,?Int.!Int]
                   , l : {!Int,!Int.!Int}
                   ) =
  fwd {?Int,!Int.?Int} i o l.
fwd_par2_ten2_ten2 ( i : {?Int,!Int.?Int}
                   , o : [!Int,?Int.!Int]
                   , l : {!Int,!Int.!Int}
                   , m : {!Int,!Int.!Int}
                   ) =
  fwd {?Int,!Int.?Int} i o l m.
fwd_send_recv (i : ?Int, o : !Int) = fwd (?Int) i o.
fwd_send_recv (i : ?Int. !Int, o : !Int. ?Int) = fwd (?Int.!Int) i o.
id : (A : Type)(x : A) -> A.

idproc (c : ?Int, d : !Int) =
  recv c (y : Int)
  send d (id Int y).
m : Int.
n : Int.

merger ( c0 : [! Vec Int m, ? Vec Int m]
       , c1 : [! Vec Int n, ? Vec Int n]
       , ci : ? Vec Int (m + n)
       , co : ! Vec Int (m + n)
       ) =
  c0[c0i,c0o]
  c1[c1i,c1o]
  recv ci (vi : Vec Int (m + n))
  ( send c0i (take Int m n vi)
  | send c1i (drop Int m n vi)
  | recv c0o (v0 : Vec Int m)
    recv c1o (v1 : Vec Int n)
    send co  (merge m n v0 v1)
  ).
m : Int.
n : Int.

merger_seq_inferred (c0,c1,ci,co) =
  recv ci (vi : Vec Int (m + n))
  send c0 (take Int m n vi) -- Since these two sends are on different channels
  send c1 (drop Int m n vi) -- they can commute, thus are actually in parallel
  recv c0 (v0 : Vec Int m)  -- Same here these two recv can commute
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)
.
m : Int.
n : Int.

merger_seq ( c0 : ! Vec Int m. ? Vec Int m
           , c1 : ! Vec Int n. ? Vec Int n
           , ci : ? Vec Int (m + n)
           , co : ! Vec Int (m + n)
           ) =
  recv ci (vi : Vec Int (m + n))
  send c0 (take Int m n vi) -- Since these two sends are on different channels
  send c1 (drop Int m n vi) -- they can commute, thus are actually in parallel
  recv c0 (v0 : Vec Int m)  -- Same here these two recv can commute
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)
.
m : Int.
n : Int.

merger_seq (c : [Sort Int m, Sort Int n] -o Sort Int (m + n)) =
  c{d,io} d{d0,d1}
  recv io (vi : Vec Int (m + n))
  send d0 (take Int m n vi) -- Since these two sends are on different channels
  send d1 (drop Int m n vi) -- they can commute, thus are actually in parallel
  recv d0 (v0 : Vec Int m)  -- Same here these two recv can commute
  recv d1 (v1 : Vec Int n)
  send io (merge m n v0 v1)
.
par0 (c : {}) = c{}.
par1 (c : {!Int}) = c{d} send d 42.
par2 (c : {!Int,?Int}) = c{d,e} recv e (x : Int) send d x.
par2mix (c : {!Int,?Int}) = c{d,e}(recv e (x : Int) | send d 42).
parallel_assoc_2tensor2_left (cde : [[!Int, !Int], !Int]) =
  cde[cd,e]
  cd[c,d]
  ( send c 1
  | send d 2
  | send e 3
  ).
parallel_assoc_2tensor2_right (cde : [[!Int, !Int], !Int]) =
  cde[cd,e]
  ( cd[c,d] ( send c 1 | send d 2 )
  | send e 3
  ).
parallel_assoc_flat (c : !Int, d : !Int, e : !Int) =
  ( send c 1
  | send d 2
  | send e 3
  ).
parallel_assoc_left (c : !Int, d : !Int, e : !Int) =
  ( ( send c 1 | send d 2 )
  | send e 3
  ).
parallel_assoc_right (c : !Int, d : !Int, e : !Int) =
  ( send c 1
  | ( send d 2 | send e 3 )
  ).
parallel_assoc_tensor3_flat (cde : [!Int, !Int, !Int]) =
  cde[c,d,e]
  ( send c 1
  | send d 2
  | send e 3
  ).
parallel_assoc_tensor3_left (cde : [!Int, !Int, !Int]) =
  cde[c,d,e]
  ( send c 1
  | ( send d 2 | send e 3 )
  ).
parallel_assoc_tensor3_right (cde : [!Int, !Int, !Int]) =
  cde[c,d,e]
  ( ( send c 1 | send d 2 )
  | send e 3
  ).
parallel_tensor4_flat (cd : [!Int,!Int], ef : [!Int,!Int]) =
  cd[c,d]
  ef[e,f]
  ( send c 1
  | send e 2
  | send d 3
  | send f 4
  ).
-- Needs mix
-- [c,d],[e,f] <mix> [c,d,e,f] <split> [c,e],[d,f] <split/split> [c],[e] and [d],[f]
parallel_tensor4_v0 (cd : [!Int,!Int], ef : [!Int,!Int]) =
  cd[c,d]
  ef[e,f]
  ( ( send c 1 | send e 2 )
  | ( send d 3 | send f 4 )
  ).
par_ten1_ten1 (c : {[?Int], [!Int]}) =
  c{e,d} d[l] e[h]
  recv h (x : Int) send l x.
par_ten_ten_v1 (c : {[?Int, !Int], [!Int, ?Int]}) =
  c{e,d} d[k,l] e[h,g]
  ( recv h (x : Int)
  | send k 1
  | recv l (y : Int)
  | send g 2
  ).
par_ten_ten_v2 (c : {[?Int, !Int], [!Int, ?Int]}) =
  c{e,d} d[k,l] e[h,g]
  ( ( send k 1
    | ( recv h (x : Int) | recv l (y : Int) )
    )
  | send g 2
  ).
replicate_par (c : {!Int ^ 10}) =
  slice 10 as i
    c{d}
      send d i.
replicate_ten (c : [!Int ^ 10]) =
  slice 10 as i
    c[d]
      send d i.
seq3 (c : [: !Int, !Int, !Int :]) =
  c[: c0, c1, c2 :]
  send c0 0
  send c1 1
  send c2 2
.
seq3_seq2 (c : [: !Int, !Int, !Int :], d : [: !Int, !Int :]) =
  c[: c0, c1, c2 :]
  d[: d0, d1 :]
  send c0 0
  send c1 1
  send d0 0
  send c2 2
  send d1 1
.
singleRecv (c : ?Int) = recv c (x : Int).
singleSend (c : !Int) = send c 42.
n : Int.

sorter (c : {? Vec Int n, ! Vec Int n}) =
  c{ci,co}
  recv ci (v : Vec Int n)
  send co (sort n v).
ten_loli_par (c : [!Int,!Int] -o {!Int,!Int}) =
  c{i,o}
  i{i0,i1}
  o{o0,o1}
  ( fwd (?Int) i0 o0
  | fwd (?Int) i1 o1
  ).
ten_par_par_split (c : [{},{}]) = c[d,e] (d{} | e{}).
tensor0 (c : []) = c[].
tensor1 (c : [!Int]) = c[d] send d 42.
tensor2 (c : [!Int,?Int]) = c[d,e](recv e (x : Int) | send d 42).
tensor2_tensor0_tensor0_parallel (cd : [[], []]) =
  cd[c,d] ( c[] | d[] ).
{-
          d[] : [d : []]
       c[]d[] : [c : [], d : []]
cd[c,d]c[]d[] : [cd : [[], []]]
-}
tensor2_tensor0_tensor0_sequence (cd : [[], []]) =
  cd[c,d] c[] d[].
tensor2_using_dual (c : [!Int,~!Int]) = c[d,e](recv e (x : Int) | send d 42).
test2 =
  new (c : {?Int. !Int. ?Int, !Int. ?Int. !Int}, d)
  (
    c{c0,c1}
    recv c0 (x0 : Int)
    send c1 (x0 + 1)
    recv c1 (x1 : Int)
    send c0 (x1 + x0 + 2)
    recv c0 (x2 : Int)
    send c1 (x2 + x1 + x0 + 3)
  | d[d0,d1]
    (
      send d0 1
      recv d0 (y0 : Int)
      send d0 (y0 + 4)
    |
      recv d1 (z0 : Int)
      send d1 (z0 + 5)
      recv d1 (z1 : Int)
    )
  ).
test3 =
  new (c : ?Int. [!Int, !Int], d)
  (
    recv c (x0 : Int)
    c[c0,c1]
    ( send c0 x0 | send c1 x0 )
  |
    send d 1
    d{d0,d1}
    ( recv d0 (y0 : Int) | recv d1 (z0 : Int) )
  ).
test4 (r : !Int) =
  new (c : ?Int. ?Int. ?Int, d)
  (
    recv c (x0 : Int)
    recv c (x1 : Int)
    recv c (x2 : Int)
    send r (x0 + x1 + x2)
  |
    send d 1
    send d 2
    send d 3
  ).
zap_ten_fwd (cf : {(?Int -o ?Int) ^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10]) =
  slice 10 as i
  cf{cfi}
  cn{cni}
  co[coi]
  cfi{cfii,cfio}
  ( fwd (?Int) cni cfii
  | fwd (?Int) cfio coi
  )
.
zap_ten_par (cf : {(?Int -o ?Int) ^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10]) =
  slice 10 as i
  cf{cfi}
  cn{cni}
  co[coi]
  cfi{cfii,cfio}
  ( recv cni (x : Int)
    send cfii x
  | recv cfio (y : Int)
    send coi y
  )
.
zap_ten_seq (cf : {(?Int -o ?Int) ^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10]) =
  slice 10 as i
  cf{cfi}
  cn{cni}
  co[coi]
  cfi{cfii,cfio}
  recv cni (x : Int)
  send cfii x
  recv cfio (y : Int)
  send coi y
.
zip_add (xs : {?Int ^ 10}, ys : {?Int ^ 10}, zs : [!Int ^ 10]) =
  slice 10 as i
    xs{x}
      ys{y}
        zs[z]
          recv x (a : Int)
          recv y (b : Int)
          send z (a + b).
