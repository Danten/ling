
{- Sequential process -}

cutEmptyParTensor =
  proc ()
  new (c : {}, d : [])
  c {}
  d []


cut_par_cut =
  proc ()
  new (c : !Int, d : ?Int)
  new (c' : !Int, d' : ?Int)
  send c 1
  recv d (x : Int)
  send c' 1
  recv d' (x' : Int)


cut_recv_send_send_recv =
  proc ()
  new (d : ?Int.!Int, c : !Int.?Int)
  send c 1
  recv d (y : Int)
  send d 2
  recv c (x : Int)


cutSendRecv =
  proc ()
  new (c : !Int, d : ?Int)
  send c 1
  recv d (x : Int)


cut_send_recv_recv_send =
  proc ()
  new (c : !Int.?Int, d : ?Int.!Int)
  send c 1
  recv d (y : Int)
  send d 2
  recv c (x : Int)


cut_send_recv_recv_send_v2 =
  proc ()
  new (c : !Int.?Int, d : ?Int.!Int)
  send c 1
  recv d (y : Int)
  send d 2
  recv c (x : Int)


double =
  proc (i : ?Int, r : !Int)
  recv i (xi : Int)
  new (c : ?Int.?Int.!Int, d)
  send d xi
  recv c (x : Int)
  send d xi
  recv c (y : Int)
  send c (x + y)
  recv d (z : Int)
  send r z


fwd2_par2_ten2 =
  proc (c : {{?Int, !Int.?Int},[!Int, ?Int.!Int]})
  c {c0#, c1#}
  c1# [c1#0#, c1#1#]
  c0# {c0#0#, c0#1#}
  recv c0#0# (x#c0#0# : Int)
  recv c1#1# (x#c1#1# : Int)
  send c1#0# x#c0#0#
  send c0#1# x#c1#1#
  recv c0#1# (x#c0#1# : Int)
  send c1#1# x#c0#1#


fwd3_par2_ten2_ten2 =
  proc (c : {{?Int, !Int.?Int},[!Int, ?Int.!Int],{!Int, !Int.!Int}})
  c {c0#, c1#, c2#}
  c1# [c1#0#, c1#1#]
  c0# {c0#0#, c0#1#}
  c2# {c2#0#, c2#1#}
  recv c0#0# (x#c0#0# : Int)
  recv c1#1# (x#c1#1# : Int)
  send c1#0# x#c0#0#
  send c0#1# x#c1#1#
  send c2#0# x#c0#0#
  send c2#1# x#c1#1#
  recv c0#1# (x#c0#1# : Int)
  send c1#1# x#c0#1#
  send c2#1# x#c0#1#


fwd_par0_ten0 =
  proc (i : {}, o : [])
  o []
  i {}


fwd_par2_ten2_expanded =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int])
  o [o0, o1]
  i {i0, i1}
  recv i0 (xi0 : Int)
  recv o1 (xo1 : Int)
  send o0 xi0
  send i1 xo1
  recv i1 (yi1 : Int)
  send o1 yi1


fwd_par2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int])
  o [o0#, o1#]
  i {i0#, i1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0#
  send i1# x#o1#
  recv i1# (x#i1# : Int)
  send o1# x#i1#


fwd_par2_ten2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int],l : {!Int, !Int.!Int})
  o [o0#, o1#]
  i {i0#, i1#}
  l {l0#, l1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0#
  send i1# x#o1#
  send l0# x#i0#
  send l1# x#o1#
  recv i1# (x#i1# : Int)
  send o1# x#i1#
  send l1# x#i1#


fwd_par2_ten2_ten2_ten2 =
  proc (i : {?Int, !Int.?Int},o : [!Int, ?Int.!Int],l : {!Int, !Int.!Int},m : {!Int, !Int.!Int})
  o [o0#, o1#]
  i {i0#, i1#}
  l {l0#, l1#}
  m {m0#, m1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0#
  send i1# x#o1#
  send l0# x#i0#
  send l1# x#o1#
  send m0# x#i0#
  send m1# x#o1#
  recv i1# (x#i1# : Int)
  send o1# x#i1#
  send l1# x#i1#
  send m1# x#i1#


fwd_send_recv =
  proc (i : ?Int, o : !Int)
  recv i (x#i : Int)
  send o x#i


fwd_send_recv_recv_send =
  proc (i : ?Int.!Int, o : !Int.?Int)
  recv i (x#i : Int)
  send o x#i
  recv o (x#o : Int)
  send i x#o


fwd_ten2_par2 =
  proc (i : [?Int, !Int.?Int],o : {!Int, ?Int.!Int})
  i [i0#, i1#]
  o {o0#, o1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0#
  send i1# x#o1#
  recv i1# (x#i1# : Int)
  send o1# x#i1#


id : (A : Type)-> (x : A)-> A

idproc =
  proc (c : ?Int, d : !Int)
  recv c (y : Int)
  send d (id Int y)


merger_seq_inferred =
  \ (m : Int)-> \ (n : Int)-> proc (c0, c1, ci, co)
  recv ci (vi : Vec Int (m + n))
  send c0 (take Int m n vi)
  send c1 (drop Int m n vi)
  recv c0 (v0 : Vec Int m)
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)


merger_seq =
  \ (m : Int)-> \ (n : Int)-> proc (c0 : !Vec Int m.?Vec Int m, c1 : !Vec Int n.?Vec Int n, ci : ?Vec Int (m + n),co : !Vec Int (m + n))
  recv ci (vi : Vec Int (m + n))
  send c0 (take Int m n vi)
  send c1 (drop Int m n vi)
  recv c0 (v0 : Vec Int m)
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)


merger_seq_Sort =
  \ (m : Int)-> \ (n : Int)-> proc (c : {{!Vec Int m.?Vec Int m, !Vec Int n.?Vec Int n},?Vec Int (m + n).!Vec Int (m + n)})
  c {d, io}
  d {d0, d1}
  recv io (vi : Vec Int (m + n))
  send d0 (take Int m n vi)
  send d1 (drop Int m n vi)
  recv d0 (v0 : Vec Int m)
  recv d1 (v1 : Vec Int n)
  send io (merge m n v0 v1)


par0 =
  proc (c : {})
  c {}


par1 =
  proc (c : {!Int})
  c {d}
  send d 42


par2 =
  proc (c : {!Int, ?Int})
  c {d, e}
  recv e (x : Int)
  send d x


par2mix =
  proc (c : {!Int, ?Int})
  c {d, e}
  recv e (x : Int)
  send d 42


parallel_assoc_2tensor2_left =
  proc (cde : [[!Int, !Int],!Int])
  cde [cd, e]
  cd [c, d]
  send c 1
  send d 2
  send e 3


parallel_assoc_2tensor2_right =
  proc (cde : [[!Int, !Int],!Int])
  cde [cd, e]
  cd [c, d]
  send e 3
  send c 1
  send d 2


parallel_assoc_flat =
  proc (c : !Int, d : !Int, e : !Int)
  send c 1
  send d 2
  send e 3


parallel_assoc_left =
  proc (c : !Int, d : !Int, e : !Int)
  send c 1
  send d 2
  send e 3


parallel_assoc_right =
  proc (c : !Int, d : !Int, e : !Int)
  send c 1
  send d 2
  send e 3


parallel_assoc_tensor3_flat =
  proc (cde : [!Int, !Int, !Int])
  cde [c, d, e]
  send c 1
  send d 2
  send e 3


parallel_assoc_tensor3_left =
  proc (cde : [!Int, !Int, !Int])
  cde [c, d, e]
  send c 1
  send d 2
  send e 3


parallel_assoc_tensor3_right =
  proc (cde : [!Int, !Int, !Int])
  cde [c, d, e]
  send c 1
  send d 2
  send e 3


parallel_tensor4_flat =
  proc (cd : [!Int, !Int],ef : [!Int, !Int])
  cd [c, d]
  ef [e, f]
  send c 1
  send e 2
  send d 3
  send f 4


parallel_tensor4_v0 =
  proc (cd : [!Int, !Int],ef : [!Int, !Int])
  cd [c, d]
  ef [e, f]
  send c 1
  send e 2
  send d 3
  send f 4


par_ten1_ten1 =
  proc (c : {[?Int],[!Int]})
  c {e, d}
  d [l]
  e [h]
  recv h (x : Int)
  send l x


par_ten_ten_v0 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  c {e, d}
  d [k, l]
  e [h, g]
  recv h (x : Int)
  send k 1
  recv l (y : Int)
  send g 2


par_ten_ten_v1 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  c {e, d}
  d [k, l]
  e [h, g]
  recv h (x : Int)
  send k 1
  recv l (y : Int)
  send g 2


par_ten_ten_v2 =
  proc (c : {[?Int, !Int],[!Int, ?Int]})
  c {e, d}
  d [k, l]
  e [h, g]
  send k 1
  recv h (x : Int)
  recv l (y : Int)
  send g 2


replicate_par =
  proc (c : {!Int ^ 10})
  c {d}
  slice (d)10 as i
  send d i


replicate_ten =
  proc (c : [!Int ^ 10])
  c [d]
  slice (d)10 as i
  send d i


seq3 =
  proc (c : [: !Int, !Int, !Int :])
  c [: c0, c1, c2 :]
  send c0 0
  send c1 1
  send c2 2


seq3_seq2 =
  proc (c : [: !Int, !Int, !Int :], d : [: !Int, !Int :])
  c [: c0, c1, c2 :]
  d [: d0, d1 :]
  send c0 0
  send c1 1
  send d0 0
  send c2 2
  send d1 1


singleRecv =
  proc (c : ?Int)
  recv c (x : Int)


singleSend =
  proc (c : !Int)
  send c 42


sorter =
  \ (n : Int)-> proc (c : {?Vec Int n, !Vec Int n})
  c {ci, co}
  recv ci (v : Vec Int n)
  send co (sort n v)


sum_int =
  proc (a : {?Int ^ 10},r : !Int)
  new (itmp : !Int.?Int, tmp)
  send itmp 0
  a {ai}
  (slice (ai)10 as i
  recv ai (x : Int)
  recv tmp (y : Int)
  send tmp (x + y)
  | recv itmp (x#itmp : Int)
  send r x#itmp
  )

ten_loli_par =
  proc (c : {{?Int, ?Int},{!Int, !Int}})
  c {i, o}
  i {i0, i1}
  o {o0, o1}
  recv i0 (x#i0 : Int)
  recv i1 (x#i1 : Int)
  send o0 x#i0
  send o1 x#i1


ten_par_par_split =
  proc (c : [{}, {}])
  c [d, e]
  d {}
  e {}


tensor0 =
  proc (c : [])
  c []


tensor1 =
  proc (c : [!Int])
  c [d]
  send d 42


tensor2 =
  proc (c : [!Int, ?Int])
  c [d, e]
  recv e (x : Int)
  send d 42


tensor2_tensor0_tensor0_parallel =
  proc (cd : [[], []])
  cd [c, d]
  c []
  d []


tensor2_tensor0_tensor0_sequence =
  proc (cd : [[], []])
  cd [c, d]
  c []
  d []


tensor2_using_dual =
  proc (c : [!Int, ?Int])
  c [d, e]
  recv e (x : Int)
  send d 42


test2 =
  proc ()
  new (c : {?Int.!Int.?Int, !Int.?Int.!Int},d)
  c {c0, c1}
  d [d0, d1]
  send d0 1
  recv c0 (x0 : Int)
  send c1 (x0 + 1)
  recv d1 (z0 : Int)
  send d1 (z0 + 5)
  recv c1 (x1 : Int)
  send c0 (x1 + x0 + 2)
  recv d0 (y0 : Int)
  send d0 (y0 + 4)
  recv c0 (x2 : Int)
  send c1 (x2 + x1 + x0 + 3)
  recv d1 (z1 : Int)


test3 =
  proc ()
  new (c : ?Int.[!Int, !Int],d)
  send d 1
  recv c (x0 : Int)
  d {d0, d1}
  c [c0, c1]
  send c0 x0
  send c1 x0
  recv d0 (y0 : Int)
  recv d1 (z0 : Int)


test4 =
  proc (r : !Int)
  new (c : ?Int.?Int.?Int, d)
  send d 1
  recv c (x0 : Int)
  send d 2
  recv c (x1 : Int)
  send d 3
  recv c (x2 : Int)
  send r (x0 + x1 + x2)


zap_ten_fwd =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  cf {cfi}
  cn {cni}
  co [coi]
  slice (cfi, cni, coi)10 as i
  cfi {cfii, cfio}
  recv cni (x#cni : Int)
  recv cfio (x#cfio : Int)
  send cfii x#cni
  send coi x#cfio


zap_ten_par =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  cf {cfi}
  cn {cni}
  co [coi]
  slice (cfi, cni, coi)10 as i
  cfi {cfii, cfio}
  recv cni (x : Int)
  recv cfio (y : Int)
  send cfii x
  send coi y


zap_ten_seq =
  proc (cf : {{!Int, ?Int}^ 10},cn : {?Int ^ 10},co : [!Int ^ 10])
  cf {cfi}
  cn {cni}
  co [coi]
  slice (cfi, cni, coi)10 as i
  cfi {cfii, cfio}
  recv cni (x : Int)
  send cfii x
  recv cfio (y : Int)
  send coi y


zip_add =
  proc (xs : {?Int ^ 10},ys : {?Int ^ 10},zs : [!Int ^ 10])
  xs {x}
  ys {y}
  zs [z]
  slice (x, y, z)10 as i
  recv x (a : Int)
  recv y (b : Int)
  send z (a + b)

