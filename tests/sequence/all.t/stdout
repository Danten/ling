
[Sequential process]

cutEmptyParTensor  =
  new (c : {}, d : [])
  c {} 
  d [] 
  .
cut_par_cut  =
  new (c : !Int, d : ?Int)
  new (c' : !Int, d' : ?Int)
  send c 1 
  recv d (x : Int)
  send c' 1 
  recv d' (x : Int)
  .
cutSendRecv  =
  new (c : !Int, d : ?Int)
  send c 1 
  recv d (x : Int)
  .
double (i : ?Int, r : !Int) =
  recv i (xi : Int)
  new (c : ?Int .?Int .!Int, d)
  send d xi 
  recv c (x : Int)
  send d xi 
  recv c (y : Int)
  send c (x + y)
  recv d (z : Int)
  send r z 
  .
fwd_par0_ten0 (i : {}, o : []) =
  o [] 
  i {} 
  .
fwd_par2_ten2 (i : {?Int, !Int .?Int}, o : [!Int, ?Int .!Int])  =
  o [o0#, o1#]
  i {i0#, i1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0# 
  send i1# x#o1# 
  recv i1# (x#i1# : Int)
  send o1# x#i1# 
  .
fwd_par2_ten2_ten2 (i : {?Int, !Int .?Int}, o : [!Int, ?Int .!Int], l : {!Int, !Int .!Int})  =
  o [o0#, o1#]
  i {i0#, i1#}
  l {l0#, l1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0# 
  send i1# x#o1# 
  send l0# x#i0# 
  send l1# x#o1# 
  recv i1# (x#i1# : Int)
  send o1# x#i1# 
  send l1# x#i1# 
  .
fwd_par2_ten2_ten2 (i : {?Int, !Int .?Int}, o : [!Int, ?Int .!Int], l : {!Int, !Int .!Int}, m : {!Int, !Int .!Int})  =
  o [o0#, o1#]
  i {i0#, i1#}
  l {l0#, l1#}
  m {m0#, m1#}
  recv i0# (x#i0# : Int)
  recv o1# (x#o1# : Int)
  send o0# x#i0# 
  send i1# x#o1# 
  send l0# x#i0# 
  send l1# x#o1# 
  send m0# x#i0# 
  send m1# x#o1# 
  recv i1# (x#i1# : Int)
  send o1# x#i1# 
  send l1# x#i1# 
  send m1# x#i1# 
  .
fwd_send_recv (i : ?Int, o : !Int) =
  recv i (x#i : Int)
  send o x#i 
  .
fwd_send_recv (i : ?Int .!Int, o : !Int .?Int) =
  recv i (x#i : Int)
  send o x#i 
  recv o (x#o : Int)
  send i x#o 
  .
id : (A : Type)-> (x : A)-> A .
idproc (c : ?Int, d : !Int) =
  recv c (y : Int)
  send d (id Int y)
  .
m : Int .
n : Int .
merger (c0 : [!Vec Int m, ?Vec Int m], c1 : [!Vec Int n, ?Vec Int n], ci : ?Vec Int (m + n), co : !Vec Int (m + n))  =
  c0 [c0i, c0o]
  c1 [c1i, c1o]
  recv ci (vi : Vec Int (m + n)) 
  send c0i (take Int m n vi)
  send c1i (drop Int m n vi)
  recv c0o (v0 : Vec Int m)
  recv c1o (v1 : Vec Int n)
  send co (merge m n v0 v1)
  .
m : Int .
n : Int .
merger_seq_inferred (c0, c1, ci, co) =
  recv ci (vi : Vec Int (m + n)) 
  send c0 (take Int m n vi)
  send c1 (drop Int m n vi)
  recv c0 (v0 : Vec Int m)
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)
  .
m : Int .
n : Int .
merger_seq (c0 : !Vec Int m .?Vec Int m, c1 : !Vec Int n .?Vec Int n, ci : ?Vec Int (m + n), co : !Vec Int (m + n))  =
  recv ci (vi : Vec Int (m + n)) 
  send c0 (take Int m n vi)
  send c1 (drop Int m n vi)
  recv c0 (v0 : Vec Int m)
  recv c1 (v1 : Vec Int n)
  send co (merge m n v0 v1)
  .
m : Int .
n : Int .
merger_seq (c : {{!Vec Int m .?Vec Int m, !Vec Int n .?Vec Int n}, ?Vec Int (m + n).!Vec Int (m + n)}) =
  c {d, io}
  d {d0, d1}
  recv io (vi : Vec Int (m + n)) 
  send d0 (take Int m n vi)
  send d1 (drop Int m n vi)
  recv d0 (v0 : Vec Int m)
  recv d1 (v1 : Vec Int n)
  send io (merge m n v0 v1)
  .
par0 (c : {}) =
  c {} 
  .
par1 (c : {!Int})  =
  c {d}
  send d 42 
  .
par2 (c : {!Int, ?Int})  =
  c {d, e}
  recv e (x : Int)
  send d x 
  .
par2mix (c : {!Int, ?Int})  =
  c {d, e}
  recv e (x : Int)
  send d 42 
  .
parallel_assoc_2tensor2_left (cde : [[!Int, !Int], !Int])  =
  cde [cd, e]
  cd [c, d]
  send c 1 
  send d 2 
  send e 3 
  .
parallel_assoc_2tensor2_right (cde : [[!Int, !Int], !Int])  =
  cde [cd, e]
  cd [c, d]
  send e 3 
  send c 1 
  send d 2 
  .
parallel_assoc_flat (c : !Int, d : !Int, e : !Int) =
  send c 1 
  send d 2 
  send e 3 
  .
parallel_assoc_left (c : !Int, d : !Int, e : !Int) =
  send c 1 
  send d 2 
  send e 3 
  .
parallel_assoc_right (c : !Int, d : !Int, e : !Int) =
  send c 1 
  send d 2 
  send e 3 
  .
parallel_assoc_tensor3_flat (cde : [!Int, !Int, !Int])  =
  cde [c, d, e]
  send c 1 
  send d 2 
  send e 3 
  .
parallel_assoc_tensor3_left (cde : [!Int, !Int, !Int])  =
  cde [c, d, e]
  send c 1 
  send d 2 
  send e 3 
  .
parallel_assoc_tensor3_right (cde : [!Int, !Int, !Int])  =
  cde [c, d, e]
  send c 1 
  send d 2 
  send e 3 
  .
parallel_tensor4_flat (cd : [!Int, !Int], ef : [!Int, !Int])  =
  cd [c, d]
  ef [e, f]
  send c 1 
  send e 2 
  send d 3 
  send f 4 
  .
parallel_tensor4_v0 (cd : [!Int, !Int], ef : [!Int, !Int])  =
  cd [c, d]
  ef [e, f]
  send c 1 
  send e 2 
  send d 3 
  send f 4 
  .
par_ten1_ten1 (c : {[?Int], [!Int]}) =
  c {e, d}
  d [l]
  e [h]
  recv h (x : Int)
  send l x 
  .
par_ten_ten_v1 (c : {[?Int, !Int], [!Int, ?Int]}) =
  c {e, d}
  d [k, l]
  e [h, g]
  recv h (x : Int)
  send k 1 
  recv l (y : Int)
  send g 2 
  .
par_ten_ten_v2 (c : {[?Int, !Int], [!Int, ?Int]}) =
  c {e, d}
  d [k, l]
  e [h, g]
  send k 1 
  recv h (x : Int)
  recv l (y : Int)
  send g 2 
  .
replicate_par (c : {!Int ^ 10})  =
  slice 10 as i 
  c {d}
  send d i 
  .
replicate_ten (c : [!Int ^ 10])  =
  slice 10 as i 
  c [d]
  send d i 
  .
seq3 (c : [: !Int, !Int, !Int :]) =
  c [: c0, c1, c2 :] 
  send c0 0 
  send c1 1 
  send c2 2 
  .
seq3_seq2 (c : [: !Int, !Int, !Int :], d : [: !Int, !Int :]) =
  c [: c0, c1, c2 :] 
  d [: d0, d1 :] 
  send c0 0 
  send c1 1 
  send d0 0 
  send c2 2 
  send d1 1 
  .
singleRecv (c : ?Int) =
  recv c (x : Int)
  .
singleSend (c : !Int) =
  send c 42 
  .
n : Int .
sorter (c : {?Vec Int n, !Vec Int n})  =
  c {ci, co}
  recv ci (v : Vec Int n)
  send co (sort n v)
  .
ten_loli_par (c : {{?Int, ?Int}, {!Int, !Int}}) =
  c {i, o}
  i {i0, i1}
  o {o0, o1}
  recv i0 (x#i0 : Int)
  recv i1 (x#i1 : Int)
  send o0 x#i0 
  send o1 x#i1 
  .
ten_par_par_split (c : [{}, {}])  =
  c [d, e]
  d {} 
  e {} 
  .
tensor0 (c : []) =
  c [] 
  .
tensor1 (c : [!Int])  =
  c [d]
  send d 42 
  .
tensor2 (c : [!Int, ?Int])  =
  c [d, e]
  recv e (x : Int)
  send d 42 
  .
tensor2_tensor0_tensor0_parallel (cd : [[], []])  =
  cd [c, d]
  c [] 
  d [] 
  .
tensor2_tensor0_tensor0_sequence (cd : [[], []])  =
  cd [c, d]
  c [] 
  d [] 
  .
tensor2_using_dual (c : [!Int, ?Int])  =
  c [d, e]
  recv e (x : Int)
  send d 42 
  .
test2  =
  new (c : {?Int .!Int .?Int, !Int .?Int .!Int}, d)
  c {c0, c1}
  d [d0, d1]
  send d0 1 
  recv c0 (x0 : Int)
  send c1 (x0 + 1)
  recv d1 (z0 : Int)
  send d1 (z0 + 5)
  recv c1 (x1 : Int)
  send c0 (x1 + x0 + 2)
  recv d0 (y0 : Int)
  send d0 (y0 + 4)
  recv c0 (x2 : Int)
  send c1 (x2 + x1 + x0 + 3)
  recv d1 (z1 : Int)
  .
test3  =
  new (c : ?Int .[!Int, !Int], d)
  send d 1 
  recv c (x0 : Int)
  d {d0, d1}
  c [c0, c1]
  send c0 x0 
  send c1 x0 
  recv d0 (y0 : Int)
  recv d1 (z0 : Int)
  .
test4 (r : !Int) =
  new (c : ?Int .?Int .?Int, d)
  send d 1 
  recv c (x0 : Int)
  send d 2 
  recv c (x1 : Int)
  send d 3 
  recv c (x2 : Int)
  send r (x0 + x1 + x2)
  .
zap_ten_fwd (cf : {{!Int, ?Int}^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10])  =
  slice 10 as i 
  cf {cfi}
  cn {cni}
  co [coi]
  cfi {cfii, cfio}
  recv cni (x#cni : Int)
  recv cfio (x#cfio : Int)
  send cfii x#cni 
  send coi x#cfio 
  .
zap_ten_par (cf : {{!Int, ?Int}^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10])  =
  slice 10 as i 
  cf {cfi}
  cn {cni}
  co [coi]
  cfi {cfii, cfio}
  recv cni (x : Int)
  recv cfio (y : Int)
  send cfii x 
  send coi y 
  .
zap_ten_seq (cf : {{!Int, ?Int}^ 10}, cn : {?Int ^ 10}, co : [!Int ^ 10])  =
  slice 10 as i 
  cf {cfi}
  cn {cni}
  co [coi]
  cfi {cfii, cfio}
  recv cni (x : Int)
  send cfii x 
  recv cfio (y : Int)
  send coi y 
  .
zip_add (xs : {?Int ^ 10}, ys : {?Int ^ 10}, zs : [!Int ^ 10])  =
  slice 10 as i 
  xs {x}
  ys {y}
  zs [z]
  recv x (a : Int)
  recv y (b : Int)
  send z (a + b)
  .

