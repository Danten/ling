layout toplevel ;
layout "of" ;

comment "--" ;
comment "{-" "-}" ;

Prg. Program ::= [Dec] ;

token Name ((letter | ["_-+*/'%^"] | digit)*
            (letter | ["_-+*/'%^"])
            (letter | ["_-+*/'%^"] | digit)*) ;

separator Name "" ;

DPrc. Dec ::= Name "(" [ChanDec] ")" "=" Proc OptDot ;
DDef. Dec ::= Name OptSig "=" TermProc OptDot ;
DSig. Dec ::= Name ":" Term OptDot ;
DDat. Dec ::= "data" Name "=" [ConName] OptDot ;
DAsr. Dec ::= "assert" Assertion ;

AEq. Assertion ::= Term "=" Term ":" Term ;

CN. ConName ::= "`" Name ;

NoDot. OptDot ::= ;
SoDot. OptDot ::= "." ;

SoTerm. TermProc ::= Term ;
SoProc. TermProc ::= Proc ;

separator ConName "|" ;

NoSig. OptSig ::= ;
SoSig. OptSig ::= ":" Term ;

separator Dec "," ;

VD. VarDec ::= "(" Name ":" Term ")" ;

-- Warning: here ATerm is used instead of Name.
-- The rule with Name would create a parsing conflict
-- (when using LALR). This grammar is thus more generous
-- and erroneous terms are rejected after in Ling.Reify.
VsD.      VarsDec ::= "(" ATerm [ATerm] ":" Term ")" ;
separator VarsDec "" ;

CD. ChanDec ::= Name OptSession ;

separator ChanDec "," ;

Br. Branch ::= ConName "->" Term ;

separator Branch "," ;

LInteger. Literal ::= Integer ;
LDouble.  Literal ::= Double  ;
LString.  Literal ::= String  ;
LChar.    Literal ::= Char    ;

-- Atomic terms
Var.     ATerm ::= Name ;
Lit.     ATerm ::= Literal ;
Con.     ATerm ::= ConName ;
TTyp.    ATerm ::= "Type" ;
TProto.  ATerm ::= "<" [RSession] ">" ;
Paren.   ATerm ::= "(" Term ")" ;

-- Sessions
End.     ATerm ::= "end" ;
Par.     ATerm ::= "{"  [RSession]  "}" ;
Ten.     ATerm ::= "["  [RSession]  "]" ;
Seq.     ATerm ::= "[:" [RSession] ":]" ;

separator ATerm "" ;

DTTyp.   DTerm ::= Name [ATerm] ;
DTBnd.   DTerm ::= "(" Name ":" Term ")" ;

RawApp.   Term2  ::= ATerm [ATerm] ;
Case.     Term2  ::= "case" Term "of" "{" [Branch] "}" ;
Snd.      Term2  ::= "!" DTerm CSession ;
Rcv.      Term2  ::= "?" DTerm CSession ;
Dual.     Term2  ::= "~" Term2 ;

Loli.     Term1  ::= Term2 "-o" Term1 ;
_.        Term1  ::= Term2 ;

TFun.     Term   ::= VarsDec [VarsDec] "->" Term ;
TSig.     Term   ::= VarsDec [VarsDec] "**" Term ;
Lam.      Term   ::= "\\" VarsDec [VarsDec] "->" Term ;
TProc.    Term   ::= "proc" "(" [ChanDec] ")" Proc ;
_.        Term   ::= Term1 ;

PAct.     Proc1 ::= Act ;
PPrll.    Proc1 ::= "(" [Proc] ")" ;

PNxt.     Proc ::= Proc1 Proc ;
PDot.     Proc ::= Proc1 "." Proc ;
_.        Proc ::= Proc1 ;
separator Proc "|" ;

Nu.       Act ::= "new" "(" ChanDec "," ChanDec ")" ;
ParSplit. Act ::= Name "{" [ChanDec] "}" ;
TenSplit. Act ::= Name "[" [ChanDec] "]" ;
SeqSplit. Act ::= Name "[:" [ChanDec] ":]" ;
Send.     Act ::= "send" Name ATerm ;
Recv.     Act ::= "recv" Name VarDec ;
NewSlice. Act ::= "slice" "(" [ChanDec] ")" ATerm "as" Name ;
Ax.       Act ::= "fwd" ASession "(" [ChanDec] ")" ;
SplitAx.  Act ::= "fwd" Integer ASession Name ;
At.       Act ::= "@" ATerm TopCPatt ;

AS.       ASession ::= ATerm ;

OldTopPatt. TopCPatt ::= "(" [ChanDec] ")" ;
ParTopPatt. TopCPatt ::= "{"  [CPatt]  "}" ;
TenTopPatt. TopCPatt ::= "["  [CPatt]  "]" ;
SeqTopPatt. TopCPatt ::= "[:" [CPatt] ":]" ;

ChaPatt.  CPatt ::= ChanDec ;
ParPatt.  CPatt ::= "{"  [CPatt]  "}" ;
TenPatt.  CPatt ::= "["  [CPatt]  "]" ;
SeqPatt.  CPatt ::= "[:" [CPatt] ":]" ;

separator CPatt "," ;

NoSession. OptSession ::= ;
SoSession. OptSession ::= ":" RSession ;

Repl. RSession ::= Term OptRepl ;
separator RSession "," ;

One.  OptRepl  ::= ;
Some. OptRepl  ::= "^" ATerm ;

Cont. CSession ::= "." Term1 ;
Done. CSession ::= ;
