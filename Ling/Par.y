-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Ling.Par where
import Ling.Abs
import Ling.Lex
import Ling.ErrM

}

%name pProgram Program
%name pListName ListName
%name pDec Dec
%name pConName ConName
%name pListConName ListConName
%name pOptSig OptSig
%name pListDec ListDec
%name pVarDec VarDec
%name pListVarDec ListVarDec
%name pChanDec ChanDec
%name pListChanDec ListChanDec
%name pBranch Branch
%name pListBranch ListBranch
%name pLiteral Literal
%name pATerm ATerm
%name pListATerm ListATerm
%name pDTerm DTerm
%name pTerm Term
%name pProc1 Proc1
%name pProc Proc
%name pListProc ListProc
%name pAct Act
%name pOptSession OptSession
%name pSession4 Session4
%name pSession3 Session3
%name pSession2 Session2
%name pSession Session
%name pRSession RSession
%name pListRSession ListRSession
%name pOptRepl OptRepl
%name pCSession CSession
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '%equal' { PT _ (TS _ 2) }
  '(' { PT _ (TS _ 3) }
  ')' { PT _ (TS _ 4) }
  '**' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '-o' { PT _ (TS _ 8) }
  '.' { PT _ (TS _ 9) }
  ':' { PT _ (TS _ 10) }
  ':]' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '>' { PT _ (TS _ 14) }
  '?' { PT _ (TS _ 15) }
  '@' { PT _ (TS _ 16) }
  'Fwd' { PT _ (TS _ 17) }
  'Log' { PT _ (TS _ 18) }
  'Sort' { PT _ (TS _ 19) }
  'Type' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  '[:' { PT _ (TS _ 22) }
  '\\' { PT _ (TS _ 23) }
  ']' { PT _ (TS _ 24) }
  '^' { PT _ (TS _ 25) }
  '`' { PT _ (TS _ 26) }
  'as' { PT _ (TS _ 27) }
  'case' { PT _ (TS _ 28) }
  'data' { PT _ (TS _ 29) }
  'end' { PT _ (TS _ 30) }
  'fwd' { PT _ (TS _ 31) }
  'new' { PT _ (TS _ 32) }
  'of' { PT _ (TS _ 33) }
  'proc' { PT _ (TS _ 34) }
  'recv' { PT _ (TS _ 35) }
  'send' { PT _ (TS _ 36) }
  'slice' { PT _ (TS _ 37) }
  '{' { PT _ (TS _ 38) }
  '|' { PT _ (TS _ 39) }
  '}' { PT _ (TS _ 40) }
  '~' { PT _ (TS _ 41) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_Name { PT _ (T_Name $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Name    :: { Name} : L_Name { Name ($1)}

Program :: { Program }
Program : ListDec { Ling.Abs.Prg $1 }
ListName :: { [Name] }
ListName : {- empty -} { [] }
         | Name { (:[]) $1 }
         | Name ',' ListName { (:) $1 $3 }
Dec :: { Dec }
Dec : Name OptSig '=' Term { Ling.Abs.DDef $1 $2 $4 }
    | Name ':' Term { Ling.Abs.DSig $1 $3 }
    | 'data' Name '=' ListConName { Ling.Abs.DDat $2 $4 }
    | '%equal' Term '=' Term ':' Term { Ling.Abs.AEq $2 $4 $6 }
ConName :: { ConName }
ConName : '`' Name { Ling.Abs.CN $2 }
ListConName :: { [ConName] }
ListConName : {- empty -} { [] }
            | ConName { (:[]) $1 }
            | ConName '|' ListConName { (:) $1 $3 }
OptSig :: { OptSig }
OptSig : {- empty -} { Ling.Abs.NoSig }
       | ':' Term { Ling.Abs.SoSig $2 }
ListDec :: { [Dec] }
ListDec : {- empty -} { [] }
        | Dec { (:[]) $1 }
        | Dec ',' ListDec { (:) $1 $3 }
VarDec :: { VarDec }
VarDec : '(' Name ':' Term ')' { Ling.Abs.VD $2 $4 }
ListVarDec :: { [VarDec] }
ListVarDec : {- empty -} { [] }
           | ListVarDec VarDec { flip (:) $1 $2 }
ChanDec :: { ChanDec }
ChanDec : Name OptSession { Ling.Abs.CD $1 $2 }
ListChanDec :: { [ChanDec] }
ListChanDec : {- empty -} { [] }
            | ChanDec { (:[]) $1 }
            | ChanDec ',' ListChanDec { (:) $1 $3 }
Branch :: { Branch }
Branch : ConName '->' Term { Ling.Abs.Br $1 $3 }
ListBranch :: { [Branch] }
ListBranch : {- empty -} { [] }
           | Branch { (:[]) $1 }
           | Branch ',' ListBranch { (:) $1 $3 }
Literal :: { Literal }
Literal : Integer { Ling.Abs.LInteger $1 }
        | Double { Ling.Abs.LDouble $1 }
        | String { Ling.Abs.LString $1 }
        | Char { Ling.Abs.LChar $1 }
ATerm :: { ATerm }
ATerm : Name { Ling.Abs.Var $1 }
      | Literal { Ling.Abs.Lit $1 }
      | ConName { Ling.Abs.Con $1 }
      | 'Type' { Ling.Abs.TTyp }
      | '<' ListRSession '>' { Ling.Abs.TProto $2 }
      | '(' Term ')' { Ling.Abs.Paren $2 }
ListATerm :: { [ATerm] }
ListATerm : {- empty -} { [] } | ListATerm ATerm { flip (:) $1 $2 }
DTerm :: { DTerm }
DTerm : Name ListATerm { Ling.Abs.DTTyp $1 (reverse $2) }
      | '(' Name ':' Term ')' { Ling.Abs.DTBnd $2 $4 }
Term :: { Term }
Term : ATerm ListATerm { Ling.Abs.RawApp $1 (reverse $2) }
     | 'case' Term 'of' '{' ListBranch '}' { Ling.Abs.Case $2 $5 }
     | VarDec ListVarDec '->' Term { Ling.Abs.TFun $1 (reverse $2) $4 }
     | VarDec ListVarDec '**' Term { Ling.Abs.TSig $1 (reverse $2) $4 }
     | '\\' VarDec ListVarDec '->' Term { Ling.Abs.Lam $2 (reverse $3) $5 }
     | 'proc' '(' ListChanDec ')' Proc { Ling.Abs.TProc $3 $5 }
Proc1 :: { Proc }
Proc1 : Act { Ling.Abs.PAct $1 }
      | '(' ListProc ')' { Ling.Abs.PPrll $2 }
Proc :: { Proc }
Proc : Proc1 Proc { Ling.Abs.PNxt $1 $2 }
     | Proc1 '.' Proc { Ling.Abs.PDot $1 $3 }
     | Proc1 { $1 }
ListProc :: { [Proc] }
ListProc : {- empty -} { [] }
         | Proc { (:[]) $1 }
         | Proc '|' ListProc { (:) $1 $3 }
Act :: { Act }
Act : 'new' '(' ChanDec ',' ChanDec ')' { Ling.Abs.Nu $3 $5 }
    | Name '{' ListChanDec '}' { Ling.Abs.ParSplit $1 $3 }
    | Name '[' ListChanDec ']' { Ling.Abs.TenSplit $1 $3 }
    | Name '[:' ListChanDec ':]' { Ling.Abs.SeqSplit $1 $3 }
    | 'send' Name ATerm { Ling.Abs.Send $2 $3 }
    | 'recv' Name VarDec { Ling.Abs.Recv $2 $3 }
    | 'slice' '(' ListName ')' ATerm 'as' Name { Ling.Abs.NewSlice $3 $5 $7 }
    | 'fwd' Session4 '(' ListName ')' { Ling.Abs.Ax $2 $4 }
    | 'fwd' Integer Session4 Name { Ling.Abs.SplitAx $2 $3 $4 }
    | '@' ATerm '(' ListName ')' { Ling.Abs.At $2 $4 }
OptSession :: { OptSession }
OptSession : {- empty -} { Ling.Abs.NoSession }
           | ':' RSession { Ling.Abs.SoSession $2 }
Session4 :: { Session }
Session4 : Name { Ling.Abs.Atm $1 }
         | 'end' { Ling.Abs.End }
         | '{' ListRSession '}' { Ling.Abs.Par $2 }
         | '[' ListRSession ']' { Ling.Abs.Ten $2 }
         | '[:' ListRSession ':]' { Ling.Abs.Seq $2 }
         | '(' Session ')' { $2 }
Session3 :: { Session }
Session3 : 'Sort' ATerm ATerm { Ling.Abs.Sort $2 $3 }
         | 'Log' Session4 { Ling.Abs.Log $2 }
         | 'Fwd' Integer Session4 { Ling.Abs.Fwd $2 $3 }
         | Session4 { $1 }
Session2 :: { Session }
Session2 : '!' DTerm CSession { Ling.Abs.Snd $2 $3 }
         | '?' DTerm CSession { Ling.Abs.Rcv $2 $3 }
         | '~' Session2 { Ling.Abs.Dual $2 }
         | Session3 { $1 }
Session :: { Session }
Session : Session2 '-o' Session { Ling.Abs.Loli $1 $3 }
        | Session2 { $1 }
RSession :: { RSession }
RSession : Session OptRepl { Ling.Abs.Repl $1 $2 }
ListRSession :: { [RSession] }
ListRSession : {- empty -} { [] }
             | RSession { (:[]) $1 }
             | RSession ',' ListRSession { (:) $1 $3 }
OptRepl :: { OptRepl }
OptRepl : {- empty -} { Ling.Abs.One }
        | '^' ATerm { Ling.Abs.Some $2 }
CSession :: { CSession }
CSession : '.' Session2 { Ling.Abs.Cont $2 }
         | {- empty -} { Ling.Abs.Done }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

