-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Lin.Par where
import Lin.Abs
import Lin.Lex
import Lin.ErrM

}

%name pListName ListName
%name pProgram Program
%name pDec Dec
%name pListDec ListDec
%name pVarDec VarDec
%name pListVarDec ListVarDec
%name pOptChanDecs OptChanDecs
%name pChanDec ChanDec
%name pListChanDec ListChanDec
%name pOp Op
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm Term
%name pListTerm3 ListTerm3
%name pProc Proc
%name pListProc ListProc
%name pProcs Procs
%name pSnk Snk
%name pListSnk ListSnk
%name pPref Pref
%name pListPref ListPref
%name pOptSession OptSession
%name pSession4 Session4
%name pSession3 Session3
%name pSession2 Session2
%name pSession Session
%name pRSession RSession
%name pListRSession ListRSession
%name pOptRepl OptRepl
%name pCSession CSession

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype { Token }

%token
  '!' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '->' { PT _ (TS _ 7) }
  '-o' { PT _ (TS _ 8) }
  '.' { PT _ (TS _ 9) }
  ':' { PT _ (TS _ 10) }
  ':]' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '>' { PT _ (TS _ 14) }
  '?' { PT _ (TS _ 15) }
  '@' { PT _ (TS _ 16) }
  'Fwd' { PT _ (TS _ 17) }
  'Log' { PT _ (TS _ 18) }
  'Sort' { PT _ (TS _ 19) }
  'Type' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  '[:' { PT _ (TS _ 22) }
  ']' { PT _ (TS _ 23) }
  '^' { PT _ (TS _ 24) }
  'as' { PT _ (TS _ 25) }
  'end' { PT _ (TS _ 26) }
  'fwd' { PT _ (TS _ 27) }
  'new' { PT _ (TS _ 28) }
  'proc' { PT _ (TS _ 29) }
  'recv' { PT _ (TS _ 30) }
  'send' { PT _ (TS _ 31) }
  'slice' { PT _ (TS _ 32) }
  'unpack' { PT _ (TS _ 33) }
  '{' { PT _ (TS _ 34) }
  '|' { PT _ (TS _ 35) }
  '}' { PT _ (TS _ 36) }
  '~' { PT _ (TS _ 37) }

L_integ  { PT _ (TI $$) }
L_Name { PT _ (T_Name $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Name    :: { Name} : L_Name { Name ($1)}

ListName :: { [Name] }
ListName : {- empty -} { [] } 
  | Name { (:[]) $1 }
  | Name ',' ListName { (:) $1 $3 }


Program :: { Program }
Program : ListDec { Program (reverse $1) } 


Dec :: { Dec }
Dec : Name OptChanDecs '=' Proc '.' { Dec $1 $2 $4 } 
  | Name ':' Term '.' { Sig $1 $3 }


ListDec :: { [Dec] }
ListDec : {- empty -} { [] } 
  | ListDec Dec { flip (:) $1 $2 }


VarDec :: { VarDec }
VarDec : '(' Name ':' Term ')' { VarDec $2 $4 } 


ListVarDec :: { [VarDec] }
ListVarDec : {- empty -} { [] } 
  | ListVarDec VarDec { flip (:) $1 $2 }


OptChanDecs :: { OptChanDecs }
OptChanDecs : {- empty -} { NoChanDecs } 
  | '(' ListChanDec ')' { SoChanDecs $2 }


ChanDec :: { ChanDec }
ChanDec : Name OptSession { ChanDec $1 $2 } 


ListChanDec :: { [ChanDec] }
ListChanDec : {- empty -} { [] } 
  | ChanDec { (:[]) $1 }
  | ChanDec ',' ListChanDec { (:) $1 $3 }


Op :: { Op }
Op : '+' { Plus } 


Term3 :: { Term }
Term3 : Name { Var $1 } 
  | Integer { Lit $1 }
  | '(' Term ':' Term ')' { EAnn $2 $4 }
  | 'Type' { TTyp }
  | '<' ListRSession '>' { TProto $2 }
  | '(' Term ')' { $2 }


Term2 :: { Term }
Term2 : Name ListTerm3 { Def $1 (reverse $2) } 
  | Term2 Op Term3 { Infix $1 $2 $3 }
  | Term3 { $1 }


Term :: { Term }
Term : VarDec ListVarDec '->' Term { TFun $1 (reverse $2) $4 } 
  | VarDec ListVarDec '*' Term { TSig $1 (reverse $2) $4 }
  | 'proc' '(' ListChanDec ')' Proc { Proc $3 $5 }
  | Term2 { $1 }


ListTerm3 :: { [Term] }
ListTerm3 : {- empty -} { [] } 
  | ListTerm3 Term3 { flip (:) $1 $2 }


Proc :: { Proc }
Proc : ListPref Procs { Act (reverse $1) $2 } 


ListProc :: { [Proc] }
ListProc : {- empty -} { [] } 
  | Proc { (:[]) $1 }
  | Proc '|' ListProc { (:) $1 $3 }


Procs :: { Procs }
Procs : {- empty -} { ZeroP } 
  | 'fwd' Session Name Name ListSnk { Ax $2 $3 $4 (reverse $5) }
  | 'unpack' Term '@' '(' ListName ')' { At $2 $5 }
  | '(' ListProc ')' { Procs $2 }


Snk :: { Snk }
Snk : Name { Snk $1 } 


ListSnk :: { [Snk] }
ListSnk : {- empty -} { [] } 
  | ListSnk Snk { flip (:) $1 $2 }


Pref :: { Pref }
Pref : 'new' '(' ChanDec ',' ChanDec ')' { Nu $3 $5 } 
  | Name '{' ListChanDec '}' { ParSplit $1 $3 }
  | Name '[' ListChanDec ']' { TenSplit $1 $3 }
  | Name '[:' ListChanDec ':]' { SeqSplit $1 $3 }
  | 'slice' Term3 'as' Name { NewSlice $2 $4 }
  | 'send' Name Term3 { Send $2 $3 }
  | 'recv' Name VarDec { Recv $2 $3 }


ListPref :: { [Pref] }
ListPref : {- empty -} { [] } 
  | ListPref Pref { flip (:) $1 $2 }


OptSession :: { OptSession }
OptSession : {- empty -} { NoSession } 
  | ':' Session { SoSession $2 }


Session4 :: { Session }
Session4 : Name { Atm $1 } 
  | 'end' { End }
  | '{' ListRSession '}' { Par $2 }
  | '[' ListRSession ']' { Ten $2 }
  | '[:' ListRSession ':]' { Seq $2 }
  | '(' Session ')' { $2 }


Session3 :: { Session }
Session3 : 'Sort' Term3 Term3 { Sort $2 $3 } 
  | 'Log' Session4 { Log $2 }
  | 'Fwd' Integer Session4 { Fwd $2 $3 }
  | Session4 { $1 }


Session2 :: { Session }
Session2 : '!' Term2 CSession { Snd $2 $3 } 
  | '?' Term2 CSession { Rcv $2 $3 }
  | '~' Session2 { Dual $2 }
  | Session3 { $1 }


Session :: { Session }
Session : Session2 '-o' Session { Loli $1 $3 } 
  | Session2 { $1 }


RSession :: { RSession }
RSession : Session OptRepl { Repl $1 $2 } 


ListRSession :: { [RSession] }
ListRSession : {- empty -} { [] } 
  | RSession { (:[]) $1 }
  | RSession ',' ListRSession { (:) $1 $3 }


OptRepl :: { OptRepl }
OptRepl : {- empty -} { One } 
  | '^' Term3 { Some $2 }


CSession :: { CSession }
CSession : '.' Session2 { Cont $2 } 
  | {- empty -} { Done }



{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

