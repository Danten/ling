

module Lin.Abs where

-- Haskell module generated by the BNF converter




newtype Name = Name String deriving (Eq,Ord,Show,Read)
data Program =
   Program [Dec]
  deriving (Eq,Ord,Show,Read)

data Dec =
   Dec Name OptChanDecs Proc
 | Sig Name Term
  deriving (Eq,Ord,Show,Read)

data VarDec =
   VarDec Name Term
  deriving (Eq,Ord,Show,Read)

data OptChanDecs =
   NoChanDecs
 | SoChanDecs [ChanDec]
  deriving (Eq,Ord,Show,Read)

data ChanDec =
   ChanDec Name OptSession
  deriving (Eq,Ord,Show,Read)

data ATerm =
   Var Name
 | Lit Integer
 | TTyp
 | TProto [RSession]
 | Paren Term
  deriving (Eq,Ord,Show,Read)

data DTerm =
   DTerm Name [ATerm]
  deriving (Eq,Ord,Show,Read)

data Term =
   RawApp ATerm [ATerm]
 | TFun VarDec [VarDec] Term
 | TSig VarDec [VarDec] Term
 | Proc [ChanDec] Proc
  deriving (Eq,Ord,Show,Read)

data Proc =
   Act [Pref] Procs
  deriving (Eq,Ord,Show,Read)

data Procs =
   ZeroP
 | Ax Session [Name]
 | At ATerm [Name]
 | NewSlice [Name] ATerm Name Proc
 | Procs [Proc]
  deriving (Eq,Ord,Show,Read)

data Pref =
   Nu ChanDec ChanDec
 | ParSplit Name [ChanDec]
 | TenSplit Name [ChanDec]
 | SeqSplit Name [ChanDec]
 | Send Name ATerm
 | Recv Name VarDec
  deriving (Eq,Ord,Show,Read)

data OptSession =
   NoSession
 | SoSession RSession
  deriving (Eq,Ord,Show,Read)

data Session =
   Atm Name
 | End
 | Par [RSession]
 | Ten [RSession]
 | Seq [RSession]
 | Sort ATerm ATerm
 | Log Session
 | Fwd Integer Session
 | Snd DTerm CSession
 | Rcv DTerm CSession
 | Dual Session
 | Loli Session Session
  deriving (Eq,Ord,Show,Read)

data RSession =
   Repl Session OptRepl
  deriving (Eq,Ord,Show,Read)

data OptRepl =
   One
 | Some ATerm
  deriving (Eq,Ord,Show,Read)

data CSession =
   Cont Session
 | Done
  deriving (Eq,Ord,Show,Read)

